From 1b00e9aa58c0cc8d8689cb9447aee855cd009800 Mon Sep 17 00:00:00 2001
From: John E Malmberg <john.e.malmberg@intel.com>
Date: Wed, 13 Nov 2019 22:07:30 +0000
Subject: [PATCH] Backport for Leap-15 from Tumbleweed Experimental

---
 ipaclient/install/client.py       |   44 +++---
 ipaplatform/opensuse/__init__.py  |   19 +++
 ipaplatform/opensuse/constants.py |   17 +++
 ipaplatform/opensuse/paths.py     |   76 ++++++++++
 ipaplatform/opensuse/services.py  |  231 ++++++++++++++++++++++++++++++
 ipaplatform/opensuse/tasks.py     |  278 +++++++++++++++++++++++++++++++++++++
 ipaplatform/setup.py              |    4 +-
 ipaplatform/suse/__init__.py      |   19 +++
 ipaplatform/suse/constants.py     |   17 +++
 ipaplatform/suse/paths.py         |   76 ++++++++++
 ipaplatform/suse/services.py      |  231 ++++++++++++++++++++++++++++++
 ipaplatform/suse/tasks.py         |  278 +++++++++++++++++++++++++++++++++++++
 12 files changed, 1267 insertions(+), 23 deletions(-)
 create mode 100644 ipaplatform/opensuse/__init__.py
 create mode 100644 ipaplatform/opensuse/constants.py
 create mode 100644 ipaplatform/opensuse/paths.py
 create mode 100644 ipaplatform/opensuse/services.py
 create mode 100644 ipaplatform/opensuse/tasks.py
 create mode 100644 ipaplatform/suse/__init__.py
 create mode 100644 ipaplatform/suse/constants.py
 create mode 100644 ipaplatform/suse/paths.py
 create mode 100644 ipaplatform/suse/services.py
 create mode 100644 ipaplatform/suse/tasks.py

diff --git a/ipaclient/install/client.py b/ipaclient/install/client.py
index 5173d90..08a3fce 100644
--- a/ipaclient/install/client.py
+++ b/ipaclient/install/client.py
@@ -642,27 +642,27 @@ def configure_krb5_conf(
         krbconf.emptyLine(),
     ]
 
-    if os.path.exists(paths.COMMON_KRB5_CONF_DIR):
-        opts.extend([
-            {
-                'name': 'includedir',
-                'type': 'option',
-                'value': paths.COMMON_KRB5_CONF_DIR,
-                'delim': ' '
-            }
-        ])
-
-    # SSSD include dir
-    if configure_sssd:
-        opts.extend([
-            {
-                'name': 'includedir',
-                'type': 'option',
-                'value': paths.SSSD_PUBCONF_KRB5_INCLUDE_D_DIR,
-                'delim': ' '
-            },
-            krbconf.emptyLine()])
-
+#   if os.path.exists(paths.COMMON_KRB5_CONF_DIR):
+#       opts.extend([
+#           {
+#               'name': 'includedir',
+#               'type': 'option',
+#               'value': paths.COMMON_KRB5_CONF_DIR,
+#               'delim': ' '
+#           }
+#       ])
+#
+#   # SSSD include dir
+#   if configure_sssd:
+#       opts.extend([
+#           {
+#               'name': 'includedir',
+#               'type': 'option',
+#               'value': paths.SSSD_PUBCONF_KRB5_INCLUDE_D_DIR,
+#               'delim': ' '
+#           },
+#           krbconf.emptyLine()])
+#
     # [libdefaults]
     libopts = [
         krbconf.setOption('default_realm', cli_realm)
@@ -2576,7 +2576,7 @@ def _install(options):
                 subject_base = DN(subject_base)
 
             if options.principal is not None:
-                run(["kdestroy"], raiseonerr=False, env=env)
+                run([paths.KDESTROY], raiseonerr=False, env=env)
 
             # Obtain the TGT. We do it with the temporary krb5.conf, so that
             # only the KDC we're installing under is contacted.
diff --git a/ipaplatform/opensuse/__init__.py b/ipaplatform/opensuse/__init__.py
new file mode 100644
index 0000000..15ae846
--- /dev/null
+++ b/ipaplatform/opensuse/__init__.py
@@ -0,0 +1,19 @@
+# Authors: Howard Guo <hguo@suse.com>
+# Copyright (C) 2015 SUSE Linux GmbH
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+'''
+This module contains SUSE specific platform files.
+'''
+
diff --git a/ipaplatform/opensuse/constants.py b/ipaplatform/opensuse/constants.py
new file mode 100644
index 0000000..9659420
--- /dev/null
+++ b/ipaplatform/opensuse/constants.py
@@ -0,0 +1,17 @@
+#
+# Copyright (C) 2015  FreeIPA Contributors see COPYING for license
+#
+
+'''
+This Red Hat OS family base platform module exports default platform
+related constants for the Red Hat OS family-based systems.
+'''
+
+# Fallback to default path definitions
+from ipaplatform.base.constants import BaseConstantsNamespace
+
+
+class SuseConstantsNamespace(BaseConstantsNamespace):
+    pass
+
+constants = SuseConstantsNamespace()
diff --git a/ipaplatform/opensuse/paths.py b/ipaplatform/opensuse/paths.py
new file mode 100644
index 0000000..b4e865e
--- /dev/null
+++ b/ipaplatform/opensuse/paths.py
@@ -0,0 +1,76 @@
+# Authors: Howard Guo <hguo@suse.com>
+# Copyright (C) 2015 SUSE Linux GmbH
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+from ipaplatform.base.paths import BasePathNamespace
+
+class SusePathNamespace(BasePathNamespace):
+    SYSTEMCTL = "/usr/bin/systemctl"
+    ETC_HTTPD_DIR = "/etc/apache2"
+    HTTPD = "/usr/sbin/httpd2"
+    HTTPD_ALIAS_DIR = "/etc/apache2/ipa"
+    ALIAS_CACERT_ASC = "/etc/apache2/ipa/cacert.asc"
+    ALIAS_PWDFILE_TXT = "/etc/apache2/ipa/pwdfile.txt"
+    LIBSOFTHSM2_SO_64 = "/usr/lib64/pkcs11/libsofthsm2.so"
+    HTTPD_CONF_D_DIR = "/etc/apache2/conf.d/"
+    HTTPD_IPA_PKI_PROXY_CONF = "/etc/apache2/conf.d/ipa-pki-proxy.conf"
+    HTTPD_IPA_REWRITE_CONF = "/etc/apache2/conf.d/ipa-rewrite.conf"
+    HTTPD_IPA_CONF = "/etc/apache2/conf.d/ipa.conf"
+    HTTPD_NSS_CONF = "/etc/apache2/conf.d/mod_nss.conf"
+    HTTPD_SSL_CONF = "/etc/apache2/conf.d/ssl.conf"
+    IPA_KEYTAB = "/etc/apache2/ipa/ipa.keytab"
+    HTTPD_PASSWORD_CONF = "/etc/apache2/ipa/password.conf"
+    NAMED_MANAGED_KEYS_DIR = "/var/lib/named/dyn"
+    SYSCONFIG_HTTPD = "/etc/sysconfig/apache2"
+    SYSCONFIG_NTPD = "/etc/sysconfig/ntp"
+    UPDATE_CA_TRUST = "/usr/sbin/update-ca-certificates"
+    IPA_SERVER_GUARD = "/usr/lib/certmonger/ipa-server-guard"
+    IPA_DNSKEYSYNCD_REPLICA = "/usr/lib/ipa/ipa-dnskeysync-replica"
+    IPA_DNSKEYSYNCD = "/usr/lib/ipa/ipa-dnskeysyncd"
+    IPA_ODS_EXPORTER = "/usr/lib/ipa/ipa-ods-exporter"
+    DNSSEC_KEYFROMLABEL = "/usr/sbin/dnssec-keyfromlabel"
+    NAMED_PKCS11 = "/usr/sbin/named"
+    VAR_KERBEROS_KRB5KDC_DIR = "/var/lib/kerberos/krb5kdc/"
+    VAR_KRB5KDC_K5_REALM = "/var/lib/kerberos/krb5kdc/.k5."
+    CACERT_PEM = "/var/lib/kerberos/krb5kdc/cacert.pem"
+    KRB5KDC_KDC_CONF = "/var/lib/kerberos/krb5kdc/kdc.conf"
+    KDC_PEM = "/var/lib/kerberos/krb5kdc/kdc.pem"
+    VAR_LOG_HTTPD_DIR = "/var/log/apache2"
+    NAMED_VAR_DIR = "/var/lib/named"
+    NAMED_ROOT_KEY = "named.root.key" # Intentionally using relative path
+    BIND_LDAP_DNS_IPA_WORKDIR = "/var/lib/named/dyndb-ldap/ipa/"
+    BIND_LDAP_DNS_ZONE_WORKDIR = "/var/lib/named/dyndb-ldap/ipa/master/"
+    BIND_LDAP_SO = "/usr/lib/bind/ldap.so"
+    BIND_LDAP_SO_64 = "/usr/lib64/bind/ldap.so"
+    KDESTROY = "/usr/lib/mit/bin/kdestroy"
+    KINIT = "/usr/bin/kinit"
+    IPA_KEYTAB = "/etc/apache2/ipa/ipa.keytab"
+    SYSTEMWIDE_IPA_CA_CRT = "/etc/pki/trust/anchors/ipa-ca.crt"
+    CA_CRT = "/etc/apache2/ipa/ca.crt"
+    BIN_KVNO = "/usr/lib/mit/bin/kvno"
+    # volatile files
+    VAR_RUN_DIRSRV_DIR = "/run/dirsrv"
+    IPA_RENEWAL_LOCK = "/run/ipa/renewal.lock"
+    SVC_LIST_FILE = "/run/ipa/services.list"
+    SVC_LIST_DIR = "/run/ipa"
+    KRB5CC_SAMBA = "/run/samba/krb5cc_samba"
+    SLAPD_INSTANCE_SOCKET_TEMPLATE = "/run/slapd-%s.socket"
+    ALL_SLAPD_INSTANCE_SOCKETS = "/run/slapd-*.socket"
+    IPA_MEMCACHED_DIR = "/run/ipa_memcached"
+    VAR_RUN_IPA_MEMCACHED = "/run/ipa_memcached/ipa_memcached"
+    # I am not very confident about this
+    IPA_NSSDB_DIR = HTTPD_ALIAS_DIR
+
+paths = SusePathNamespace()
+
diff --git a/ipaplatform/opensuse/services.py b/ipaplatform/opensuse/services.py
new file mode 100644
index 0000000..4c922e2
--- /dev/null
+++ b/ipaplatform/opensuse/services.py
@@ -0,0 +1,231 @@
+# Authors: Howard Guo <hguo@suse.com>
+# Copyright (C) 2015 SUSE Linux GmbH
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+import os
+import time
+import xml.dom.minidom
+
+from ipaplatform.tasks import tasks
+from ipaplatform.base import services as base_services
+from ipapython import ipautil, dogtag
+from ipapython.ipa_log_manager import root_logger
+from ipalib import api
+from ipaplatform.paths import paths
+
+suse_system_units = dict((x, "%s.service" % x) for x in base_services.wellknownservices)
+suse_system_units['httpd'] = 'apache2.service'
+suse_system_units['messagebus'] = 'dbus.service'
+
+suse_system_units['dirsrv'] = 'dirsrv@.service'
+suse_system_units['pkids'] = 'dirsrv@PKI-IPA.service'
+suse_system_units['pki-cad'] = 'pki-cad@pki-ca.service'
+suse_system_units['pki_cad'] = suse_system_units['pki-cad']
+suse_system_units['pki-tomcatd'] = 'pki-tomcatd@pki-tomcat.service'
+suse_system_units['pki_tomcatd'] = suse_system_units['pki-tomcatd']
+suse_system_units['ipa-otpd'] = 'ipa-otpd.socket'
+suse_system_units['ipa-dnskeysyncd'] = 'ipa-dnskeysyncd.service'
+suse_system_units['named-regular'] = 'named.service'
+suse_system_units['named-pkcs11'] = 'named.service'
+suse_system_units['named'] = 'named.service'
+suse_system_units['ods-enforcerd'] = 'ods-enforcerd.service'
+suse_system_units['ods_enforcerd'] = suse_system_units['ods-enforcerd']
+suse_system_units['ods-signerd'] = 'ods-signerd.service'
+suse_system_units['ods_signerd'] = suse_system_units['ods-signerd']
+
+
+class SuseService(base_services.SystemdService):
+    system_units = suse_system_units
+
+    def __init__(self, service_name, api=None):
+        systemd_name = service_name
+        if service_name in self.system_units:
+            systemd_name = self.system_units[service_name]
+        else:
+            if '.' not in service_name:
+                systemd_name = "%s.service" % (service_name)
+        super().__init__(service_name, systemd_name, api)
+
+
+class SuseDirectoryService(SuseService):
+    def tune_nofile_platform(self, num=8192, fstore=None):
+        pass
+
+    # Credits to upstream developer
+    def restart(self, instance_name="", capture_output=True, wait=True):
+        if instance_name:
+            elements = self.systemd_name.split("@")
+
+            srv_etc = os.path.join(paths.ETC_SYSTEMD_SYSTEM_DIR,
+                                   self.systemd_name)
+            srv_tgt = os.path.join(paths.ETC_SYSTEMD_SYSTEM_DIR,
+                                   self.SYSTEMD_SRV_TARGET % (elements[0]))
+            srv_lnk = os.path.join(srv_tgt,
+                                   self.service_instance(instance_name))
+
+            if not os.path.exists(srv_etc):
+                self.enable(instance_name)
+            elif not os.path.samefile(srv_etc, srv_lnk):
+                os.unlink(srv_lnk)
+                os.symlink(srv_etc, srv_lnk)
+
+        super().restart(instance_name,
+            capture_output=capture_output, wait=wait)
+
+
+class SuseIPAService(SuseService):
+    # Credits to upstream developer
+    def enable(self, instance_name=""):
+        super().enable(instance_name)
+        self.restart(instance_name)
+
+
+class SuseSSHService(SuseService):
+    def get_config_dir(self, instance_name=""):
+        return '/etc/ssh'
+
+
+class SuseCAService(SuseService):
+    # Credits to upstream developer
+    def wait_until_running(self):
+        use_proxy = True
+        if not (os.path.exists('/etc/apache2/conf.d/ipa.conf') and
+                os.path.exists(paths.HTTPD_IPA_PKI_PROXY_CONF)):
+            root_logger.debug(
+                'The httpd proxy is not installed, wait on local port')
+            use_proxy = False
+        root_logger.debug('Waiting until the CA is running')
+        timeout = float(api.env.startup_timeout)
+        op_timeout = time.time() + timeout
+        while time.time() < op_timeout:
+            try:
+                # FIXME https://fedorahosted.org/freeipa/ticket/4716
+                # workaround
+                #
+                # status = dogtag.ca_status(use_proxy=use_proxy)
+                #
+                port = 8443
+                if use_proxy:
+                    port = 443
+
+                url = "https://%(host_port)s%(path)s" % {
+                    "host_port": ipautil.format_netloc(api.env.ca_host, port),
+                    "path": "/ca/admin/ca/getStatus"
+                }
+
+                args = [
+                    paths.BIN_WGET,
+                    '-S', '-O', '-',
+                    '--timeout=30',
+                    '--no-check-certificate',
+                    url
+                ]
+
+                stdout, stderr, returncode = ipautil.run(args)
+
+                status = dogtag._parse_ca_status(stdout)
+                # end of workaround
+            except Exception as e:
+                status = 'check interrupted due to error: %s' % e
+            root_logger.debug('The CA status is: %s' % status)
+            if status == 'running':
+                break
+            root_logger.debug('Waiting for CA to start...')
+            time.sleep(1)
+        else:
+            raise RuntimeError('CA did not start in %ss' % timeout)
+
+    # Credits to upstream developer
+    def start(self, instance_name="", capture_output=True, wait=True):
+        super().start(
+            instance_name, capture_output=capture_output, wait=wait)
+        if wait:
+            self.wait_until_running()
+
+    # Credits to upstream developer
+    def restart(self, instance_name="", capture_output=True, wait=True):
+        super().restart(
+            instance_name, capture_output=capture_output, wait=wait)
+        if wait:
+            self.wait_until_running()
+
+
+class SuseNamedService(SuseService):
+    def get_user_name(self):
+        return u'named'
+
+    def get_group_name(self):
+        return u'named'
+
+    def get_binary_path(self):
+        return paths.NAMED_PKCS11 # identical to the ordinary named
+
+    def get_package_name(self):
+        return u"bind" # identical to the ordinary named
+
+
+class SuseODSEnforcerdService(SuseService):
+    def get_user_name(self):
+        return u'ods'
+
+    def get_group_name(self):
+        return u'ods'
+
+
+# There is not a certmonger on SUSE, therefore everything is noop.
+class SuseCertmongerService(base_services.PlatformService):
+    def __init__(self, api=None):
+        base_services.PlatformService.__init__(self, 'there-is-no-certmonger', api)
+
+    def start(instance_name="", capture_output=True, wait=True, update_service_list=True):
+        pass
+
+    def stop(self, instance_name="", capture_output=True, update_service_list=True):
+        pass
+
+
+def suse_service_class_factory(name, api):
+    if name == 'dirsrv':
+        return SuseDirectoryService(name, api)
+    if name == 'ipa':
+        return SuseIPAService(name, api)
+    if name == 'sshd':
+        return SuseSSHService(name, api)
+    if name in ('pki-cad', 'pki_cad', 'pki-tomcatd', 'pki_tomcatd'):
+        return SuseCAService(name, api)
+    if name == 'named':
+        return SuseNamedService(name, api)
+    if name in ('ods-enforcerd', 'ods_enforcerd'):
+        return SuseODSEnforcerdService(name, api)
+    if name == 'certmonger':
+        return SuseCertmongerService(api)
+    return SuseService(name, api)
+
+
+class SuseServices(base_services.KnownServices):
+    def service_class_factory(self, name, api):
+        return suse_service_class_factory(name, api)
+
+    # Credits to upstream developer
+    def __init__(self):
+        import ipalib
+        services = dict()
+        for s in base_services.wellknownservices:
+            services[s] = self.service_class_factory(s, ipalib.api)
+        super().__init__(services)
+
+
+timedate_services = ['ntpd']
+service = suse_service_class_factory
+knownservices = SuseServices()
diff --git a/ipaplatform/opensuse/tasks.py b/ipaplatform/opensuse/tasks.py
new file mode 100644
index 0000000..ffe031c
--- /dev/null
+++ b/ipaplatform/opensuse/tasks.py
@@ -0,0 +1,278 @@
+# Authors: Howard Guo <hguo@suse.com>
+# Copyright (C) 2015 SUSE Linux GmbH
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+import os
+import stat
+import socket
+import sys
+import urllib
+import base64
+
+from subprocess import CalledProcessError
+from nss.error import NSPRError
+from pyasn1.error import PyAsn1Error
+from ipapython.ipa_log_manager import root_logger, log_mgr
+from ipapython import ipautil
+import ipapython.errors
+from ipalib import x509
+from ipaplatform.paths import paths
+from ipaplatform.base.tasks import BaseTaskNamespace
+
+log = log_mgr.get_logger(__name__)
+
+class SuseTaskNamespace(BaseTaskNamespace):
+
+    def restore_context(self, filepath, restorecon=paths.SBIN_RESTORECON):
+        pass
+
+    def check_selinux_status(self, restorecon=paths.RESTORECON):
+        pass
+
+    def restore_pre_ipa_client_configuration(self, fstore, statestore,
+                                             was_sssd_installed,
+                                             was_sssd_configured):
+        print('FIXME: restore_pre_ipa_client_configuration is called')
+        pass
+
+    def set_nisdomain(self, nisdomain):
+        print('FIXME: set_nisdomain is called')
+        pass
+
+    def modify_nsswitch_pam_stack(self, sssd, mkhomedir, statestore):
+        print('FIXME: modify_nsswitch_pam_stack is called')
+        pass
+
+    def modify_pam_to_use_krb5(self, statestore):
+        print('FIXME: modify_pam_to_use_krb5 is called')
+        pass
+
+    # Credits to upstream developer
+    def reload_systemwide_ca_store(self):
+        try:
+            ipautil.run([paths.UPDATE_CA_TRUST])
+        except CalledProcessError as e:
+            root_logger.error(
+                "Could not update systemwide CA trust database: %s", e)
+            return False
+        else:
+            root_logger.info("Systemwide CA database updated.")
+            return True
+
+    # Credits to upstream developer
+    def insert_ca_certs_into_systemwide_ca_store(self, ca_certs):
+        # pylint: disable=ipa-forbidden-import
+        from ipalib import x509  # FixMe: break import cycle
+        from ipalib.errors import CertificateError
+        # pylint: enable=ipa-forbidden-import
+
+        new_cacert_path = paths.SYSTEMWIDE_IPA_CA_CRT
+
+        if os.path.exists(new_cacert_path):
+            try:
+                os.remove(new_cacert_path)
+            except OSError as e:
+                root_logger.error(
+                    "Could not remove %s: %s", new_cacert_path, e)
+                return False
+
+        new_cacert_path = paths.IPA_P11_KIT
+
+        try:
+            f = open(new_cacert_path, 'w')
+        except IOError as e:
+            root_logger.info("Failed to open %s: %s" % (new_cacert_path, e))
+            return False
+
+        f.write("# This file was created by IPA. Do not edit.\n"
+                "\n")
+
+        has_eku = set()
+        for cert, nickname, trusted, ext_key_usage in ca_certs:
+            try:
+                subject = cert.subject_bytes
+                issuer = cert.issuer_bytes
+                serial_number = cert.serial_number_bytes
+                public_key_info = cert.public_key_info_bytes
+            except (PyAsn1Error, ValueError, CertificateError) as e:
+                root_logger.warning(
+                    "Failed to decode certificate \"%s\": %s", nickname, e)
+                continue
+
+            label = urllib.parse.quote(nickname)
+            subject = urllib.parse.quote(subject)
+            issuer = urllib.parse.quote(issuer)
+            serial_number = urllib.parse.quote(serial_number)
+            public_key_info = urllib.parse.quote(public_key_info)
+
+            obj = ("[p11-kit-object-v1]\n"
+                   "class: certificate\n"
+                   "certificate-type: x-509\n"
+                   "certificate-category: authority\n"
+                   "label: \"%(label)s\"\n"
+                   "subject: \"%(subject)s\"\n"
+                   "issuer: \"%(issuer)s\"\n"
+                   "serial-number: \"%(serial_number)s\"\n"
+                   "x-public-key-info: \"%(public_key_info)s\"\n" %
+                   dict(label=label,
+                        subject=subject,
+                        issuer=issuer,
+                        serial_number=serial_number,
+                        public_key_info=public_key_info))
+            if trusted is True:
+                obj += "trusted: true\n"
+            elif trusted is False:
+                obj += "x-distrusted: true\n"
+            obj += "{pem}\n\n".format(
+                pem=cert.public_bytes(x509.Encoding.PEM).decode('ascii'))
+            f.write(obj)
+
+            if (cert.extended_key_usage is not None and
+                    public_key_info not in has_eku):
+                try:
+                    ext_key_usage = cert.extended_key_usage_bytes
+                except PyAsn1Error as e:
+                    root_logger.warning(
+                        "Failed to encode extended key usage for \"%s\": %s",
+                        nickname, e)
+                    continue
+                value = urllib.parse.quote(ext_key_usage)
+                obj = ("[p11-kit-object-v1]\n"
+                       "class: x-certificate-extension\n"
+                       "label: \"ExtendedKeyUsage for %(label)s\"\n"
+                       "x-public-key-info: \"%(public_key_info)s\"\n"
+                       "object-id: 2.5.29.37\n"
+                       "value: \"%(value)s\"\n\n" %
+                       dict(label=label,
+                            public_key_info=public_key_info,
+                            value=value))
+                f.write(obj)
+                has_eku.add(public_key_info)
+
+        f.close()
+
+        # Add the CA to the systemwide CA trust database
+        if not self.reload_systemwide_ca_store():
+            return False
+
+        return True
+
+    # Credits to upstream developer
+    def remove_ca_certs_from_systemwide_ca_store(self):
+        result = True
+        update = False
+
+        # Remove CA cert from systemwide store
+        for new_cacert_path in (paths.IPA_P11_KIT,
+                                paths.SYSTEMWIDE_IPA_CA_CRT):
+            if not os.path.exists(new_cacert_path):
+                continue
+            try:
+                os.remove(new_cacert_path)
+            except OSError as e:
+                root_logger.error(
+                    "Could not remove %s: %s", new_cacert_path, e)
+                result = False
+            else:
+                update = True
+
+        if update:
+            if not self.reload_systemwide_ca_store():
+                return False
+
+        return result
+
+    # Credits to upstream developer
+    def backup_and_replace_hostname(self, fstore, statestore, hostname):
+        old_hostname = socket.gethostname()
+        try:
+            ipautil.run([paths.BIN_HOSTNAME, hostname])
+        except ipautil.CalledProcessError as e:
+            print >>sys.stderr, ("Failed to set this machine hostname to "
+                                 "%s (%s)." % (hostname, str(e)))
+
+        filepath = paths.ETC_HOSTNAME
+        if os.path.exists(filepath):
+            # read old hostname
+            with open(filepath, 'r') as f:
+                for line in f.readlines():
+                    line = line.strip()
+                    if not line or line.startswith('#'):
+                        # skip comment or empty line
+                        continue
+                    old_hostname = line
+                    break
+            fstore.backup_file(filepath)
+
+        with open(filepath, 'w') as f:
+            f.write("%s\n" % hostname)
+        os.chmod(filepath,
+                 stat.S_IRUSR | stat.S_IWUSR | stat.S_IRGRP | stat.S_IROTH)
+        os.chown(filepath, 0, 0)
+        self.restore_context(filepath)
+
+        # store old hostname
+        statestore.backup_state('network', 'hostname', old_hostname)
+
+    # Credits to upstream developer
+    def restore_network_configuration(self, fstore, statestore):
+        old_filepath = paths.SYSCONFIG_NETWORK
+        old_hostname = statestore.get_state('network', 'hostname')
+        hostname_was_configured = False
+
+        if fstore.has_file(old_filepath):
+            # This is Fedora >=18 instance that was upgraded from previous
+            # Fedora version which held network configuration
+            # in /etc/sysconfig/network
+            old_filepath_restore = paths.SYSCONFIG_NETWORK_IPABKP
+            fstore.restore_file(old_filepath, old_filepath_restore)
+            print("Deprecated configuration file '%s' was restored to '%s'" \
+                    % (old_filepath, old_filepath_restore))
+            hostname_was_configured = True
+
+        filepath = paths.ETC_HOSTNAME
+        if fstore.has_file(filepath):
+            fstore.restore_file(filepath)
+            hostname_was_configured = True
+
+        if not hostname_was_configured and old_hostname:
+            # hostname was not configured before but was set by IPA. Delete
+            # /etc/hostname to restore previous configuration
+            try:
+                os.remove(filepath)
+            except OSError:
+                pass
+
+    def set_selinux_booleans(self, required_settings, backup_func=None):
+        return False # FIXME?
+
+    # Credits to upstream developer
+    def create_system_user(self, name, group, homedir, shell, uid = None, gid = None, comment = None):
+        if name == 'pkiuser':
+            if uid is None:
+                uid = 29
+            if gid is None:
+                gid = 29
+            if comment is None:
+                comment = 'CA System User'
+        if name == 'dirsrv':
+            if comment is None:
+                comment = 'DS System User'
+
+        super().create_system_user(name, group,
+            homedir, shell, uid, gid, comment)
+
+
+tasks = SuseTaskNamespace()
+
diff --git a/ipaplatform/setup.py b/ipaplatform/setup.py
index 1098ab6..36747b9 100644
--- a/ipaplatform/setup.py
+++ b/ipaplatform/setup.py
@@ -39,7 +39,9 @@ if __name__ == '__main__':
             "ipaplatform.debian",
             "ipaplatform.fedora",
             "ipaplatform.redhat",
-            "ipaplatform.rhel"
+            "ipaplatform.rhel",
+            "ipaplatform.suse",
+            "ipaplatform.opensuse"
         ],
         install_requires=[
             "cffi",
diff --git a/ipaplatform/suse/__init__.py b/ipaplatform/suse/__init__.py
new file mode 100644
index 0000000..15ae846
--- /dev/null
+++ b/ipaplatform/suse/__init__.py
@@ -0,0 +1,19 @@
+# Authors: Howard Guo <hguo@suse.com>
+# Copyright (C) 2015 SUSE Linux GmbH
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+'''
+This module contains SUSE specific platform files.
+'''
+
diff --git a/ipaplatform/suse/constants.py b/ipaplatform/suse/constants.py
new file mode 100644
index 0000000..9659420
--- /dev/null
+++ b/ipaplatform/suse/constants.py
@@ -0,0 +1,17 @@
+#
+# Copyright (C) 2015  FreeIPA Contributors see COPYING for license
+#
+
+'''
+This Red Hat OS family base platform module exports default platform
+related constants for the Red Hat OS family-based systems.
+'''
+
+# Fallback to default path definitions
+from ipaplatform.base.constants import BaseConstantsNamespace
+
+
+class SuseConstantsNamespace(BaseConstantsNamespace):
+    pass
+
+constants = SuseConstantsNamespace()
diff --git a/ipaplatform/suse/paths.py b/ipaplatform/suse/paths.py
new file mode 100644
index 0000000..b4e865e
--- /dev/null
+++ b/ipaplatform/suse/paths.py
@@ -0,0 +1,76 @@
+# Authors: Howard Guo <hguo@suse.com>
+# Copyright (C) 2015 SUSE Linux GmbH
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+from ipaplatform.base.paths import BasePathNamespace
+
+class SusePathNamespace(BasePathNamespace):
+    SYSTEMCTL = "/usr/bin/systemctl"
+    ETC_HTTPD_DIR = "/etc/apache2"
+    HTTPD = "/usr/sbin/httpd2"
+    HTTPD_ALIAS_DIR = "/etc/apache2/ipa"
+    ALIAS_CACERT_ASC = "/etc/apache2/ipa/cacert.asc"
+    ALIAS_PWDFILE_TXT = "/etc/apache2/ipa/pwdfile.txt"
+    LIBSOFTHSM2_SO_64 = "/usr/lib64/pkcs11/libsofthsm2.so"
+    HTTPD_CONF_D_DIR = "/etc/apache2/conf.d/"
+    HTTPD_IPA_PKI_PROXY_CONF = "/etc/apache2/conf.d/ipa-pki-proxy.conf"
+    HTTPD_IPA_REWRITE_CONF = "/etc/apache2/conf.d/ipa-rewrite.conf"
+    HTTPD_IPA_CONF = "/etc/apache2/conf.d/ipa.conf"
+    HTTPD_NSS_CONF = "/etc/apache2/conf.d/mod_nss.conf"
+    HTTPD_SSL_CONF = "/etc/apache2/conf.d/ssl.conf"
+    IPA_KEYTAB = "/etc/apache2/ipa/ipa.keytab"
+    HTTPD_PASSWORD_CONF = "/etc/apache2/ipa/password.conf"
+    NAMED_MANAGED_KEYS_DIR = "/var/lib/named/dyn"
+    SYSCONFIG_HTTPD = "/etc/sysconfig/apache2"
+    SYSCONFIG_NTPD = "/etc/sysconfig/ntp"
+    UPDATE_CA_TRUST = "/usr/sbin/update-ca-certificates"
+    IPA_SERVER_GUARD = "/usr/lib/certmonger/ipa-server-guard"
+    IPA_DNSKEYSYNCD_REPLICA = "/usr/lib/ipa/ipa-dnskeysync-replica"
+    IPA_DNSKEYSYNCD = "/usr/lib/ipa/ipa-dnskeysyncd"
+    IPA_ODS_EXPORTER = "/usr/lib/ipa/ipa-ods-exporter"
+    DNSSEC_KEYFROMLABEL = "/usr/sbin/dnssec-keyfromlabel"
+    NAMED_PKCS11 = "/usr/sbin/named"
+    VAR_KERBEROS_KRB5KDC_DIR = "/var/lib/kerberos/krb5kdc/"
+    VAR_KRB5KDC_K5_REALM = "/var/lib/kerberos/krb5kdc/.k5."
+    CACERT_PEM = "/var/lib/kerberos/krb5kdc/cacert.pem"
+    KRB5KDC_KDC_CONF = "/var/lib/kerberos/krb5kdc/kdc.conf"
+    KDC_PEM = "/var/lib/kerberos/krb5kdc/kdc.pem"
+    VAR_LOG_HTTPD_DIR = "/var/log/apache2"
+    NAMED_VAR_DIR = "/var/lib/named"
+    NAMED_ROOT_KEY = "named.root.key" # Intentionally using relative path
+    BIND_LDAP_DNS_IPA_WORKDIR = "/var/lib/named/dyndb-ldap/ipa/"
+    BIND_LDAP_DNS_ZONE_WORKDIR = "/var/lib/named/dyndb-ldap/ipa/master/"
+    BIND_LDAP_SO = "/usr/lib/bind/ldap.so"
+    BIND_LDAP_SO_64 = "/usr/lib64/bind/ldap.so"
+    KDESTROY = "/usr/lib/mit/bin/kdestroy"
+    KINIT = "/usr/bin/kinit"
+    IPA_KEYTAB = "/etc/apache2/ipa/ipa.keytab"
+    SYSTEMWIDE_IPA_CA_CRT = "/etc/pki/trust/anchors/ipa-ca.crt"
+    CA_CRT = "/etc/apache2/ipa/ca.crt"
+    BIN_KVNO = "/usr/lib/mit/bin/kvno"
+    # volatile files
+    VAR_RUN_DIRSRV_DIR = "/run/dirsrv"
+    IPA_RENEWAL_LOCK = "/run/ipa/renewal.lock"
+    SVC_LIST_FILE = "/run/ipa/services.list"
+    SVC_LIST_DIR = "/run/ipa"
+    KRB5CC_SAMBA = "/run/samba/krb5cc_samba"
+    SLAPD_INSTANCE_SOCKET_TEMPLATE = "/run/slapd-%s.socket"
+    ALL_SLAPD_INSTANCE_SOCKETS = "/run/slapd-*.socket"
+    IPA_MEMCACHED_DIR = "/run/ipa_memcached"
+    VAR_RUN_IPA_MEMCACHED = "/run/ipa_memcached/ipa_memcached"
+    # I am not very confident about this
+    IPA_NSSDB_DIR = HTTPD_ALIAS_DIR
+
+paths = SusePathNamespace()
+
diff --git a/ipaplatform/suse/services.py b/ipaplatform/suse/services.py
new file mode 100644
index 0000000..0e689bf
--- /dev/null
+++ b/ipaplatform/suse/services.py
@@ -0,0 +1,231 @@
+# Authors: Howard Guo <hguo@suse.com>
+# Copyright (C) 2015 SUSE Linux GmbH
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+import os
+import time
+import xml.dom.minidom
+
+from ipaplatform.tasks import tasks
+from ipaplatform.base import services as base_services
+from ipapython import ipautil, dogtag
+from ipapython.ipa_log_manager import root_logger
+from ipalib import api
+from ipaplatform.paths import paths
+
+suse_system_units = dict((x, "%s.service" % x) for x in base_services.wellknownservices)
+suse_system_units['httpd'] = 'apache2.service'
+suse_system_units['messagebus'] = 'dbus.service'
+
+suse_system_units['dirsrv'] = 'dirsrv@.service'
+suse_system_units['pkids'] = 'dirsrv@PKI-IPA.service'
+suse_system_units['pki-cad'] = 'pki-cad@pki-ca.service'
+suse_system_units['pki_cad'] = suse_system_units['pki-cad']
+suse_system_units['pki-tomcatd'] = 'pki-tomcatd@pki-tomcat.service'
+suse_system_units['pki_tomcatd'] = suse_system_units['pki-tomcatd']
+suse_system_units['ipa-otpd'] = 'ipa-otpd.socket'
+suse_system_units['ipa-dnskeysyncd'] = 'ipa-dnskeysyncd.service'
+suse_system_units['named-regular'] = 'named.service'
+suse_system_units['named-pkcs11'] = 'named.service'
+suse_system_units['named'] = 'named.service'
+suse_system_units['ods-enforcerd'] = 'ods-enforcerd.service'
+suse_system_units['ods_enforcerd'] = suse_system_units['ods-enforcerd']
+suse_system_units['ods-signerd'] = 'ods-signerd.service'
+suse_system_units['ods_signerd'] = suse_system_units['ods-signerd']
+
+
+class SuseService(base_services.SystemdService):
+    system_units = suse_system_units
+
+    def __init__(self, service_name, api=None):
+        systemd_name = service_name
+        if service_name in self.system_units:
+            systemd_name = self.system_units[service_name]
+        else:
+            if '.' not in service_name:
+                systemd_name = "%s.service" % (service_name)
+        super().__init__(service_name, systemd_name, api)
+
+
+class SuseDirectoryService(SuseService):
+    def tune_nofile_platform(self, num=8192, fstore=None):
+        pass
+
+    # Credits to upstream developer
+    def restart(self, instance_name="", capture_output=True, wait=True):
+        if instance_name:
+            elements = self.systemd_name.split("@")
+
+            srv_etc = os.path.join(paths.ETC_SYSTEMD_SYSTEM_DIR,
+                                   self.systemd_name)
+            srv_tgt = os.path.join(paths.ETC_SYSTEMD_SYSTEM_DIR,
+                                   self.SYSTEMD_SRV_TARGET % (elements[0]))
+            srv_lnk = os.path.join(srv_tgt,
+                                   self.service_instance(instance_name))
+
+            if not os.path.exists(srv_etc):
+                self.enable(instance_name)
+            elif not os.path.samefile(srv_etc, srv_lnk):
+                os.unlink(srv_lnk)
+                os.symlink(srv_etc, srv_lnk)
+
+        super().restart(instance_name,
+            capture_output=capture_output, wait=wait)
+
+
+class SuseIPAService(SuseService):
+    # Credits to upstream developer
+    def enable(self, instance_name=""):
+        super().enable(instance_name)
+        self.restart(instance_name)
+
+
+class SuseSSHService(SuseService):
+    def get_config_dir(self, instance_name=""):
+        return '/etc/ssh'
+
+
+class SuseCAService(SuseService):
+    # Credits to upstream developer
+    def wait_until_running(self):
+        use_proxy = True
+        if not (os.path.exists('/etc/apache2/conf.d/ipa.conf') and
+                os.path.exists(paths.HTTPD_IPA_PKI_PROXY_CONF)):
+            root_logger.debug(
+                'The httpd proxy is not installed, wait on local port')
+            use_proxy = False
+        root_logger.debug('Waiting until the CA is running')
+        timeout = float(api.env.startup_timeout)
+        op_timeout = time.time() + timeout
+        while time.time() < op_timeout:
+            try:
+                # FIXME https://fedorahosted.org/freeipa/ticket/4716
+                # workaround
+                #
+                # status = dogtag.ca_status(use_proxy=use_proxy)
+                #
+                port = 8443
+                if use_proxy:
+                    port = 443
+
+                url = "https://%(host_port)s%(path)s" % {
+                    "host_port": ipautil.format_netloc(api.env.ca_host, port),
+                    "path": "/ca/admin/ca/getStatus"
+                }
+
+                args = [
+                    paths.BIN_WGET,
+                    '-S', '-O', '-',
+                    '--timeout=30',
+                    '--no-check-certificate',
+                    url
+                ]
+
+                stdout, stderr, returncode = ipautil.run(args)
+
+                status = dogtag._parse_ca_status(stdout)
+                # end of workaround
+            except Exception as e:
+                status = 'check interrupted due to error: %s' % e
+            root_logger.debug('The CA status is: %s' % status)
+            if status == 'running':
+                break
+            root_logger.debug('Waiting for CA to start...')
+            time.sleep(1)
+        else:
+            raise RuntimeError('CA did not start in %ss' % timeout)
+
+    # Credits to upstream developer
+    def start(self, instance_name="", capture_output=True, wait=True):
+        super().start(
+            instance_name, capture_output=capture_output, wait=wait)
+        if wait:
+            self.wait_until_running()
+
+    # Credits to upstream developer
+    def restart(self, instance_name="", capture_output=True, wait=True):
+        super().restart(
+            instance_name, capture_output=capture_output, wait=wait)
+        if wait:
+            self.wait_until_running()
+
+
+class SuseNamedService(SuseService):
+    def get_user_name(self):
+        return u'named'
+
+    def get_group_name(self):
+        return u'named'
+
+    def get_binary_path(self):
+        return paths.NAMED_PKCS11 # identical to the ordinary named
+
+    def get_package_name(self):
+        return u"bind" # identical to the ordinary named
+
+
+class SuseODSEnforcerdService(SuseService):
+    def get_user_name(self):
+        return u'ods'
+
+    def get_group_name(self):
+        return u'ods'
+
+
+# There is not a certmonger on SUSE, therefore everything is noop.
+class SuseCertmongerService(base_services.PlatformService):
+    def __init__(self, api=None):
+        base_services.PlatformService.__init__(self, 'there-is-no-certmonger', api)
+
+    def start(instance_name="", capture_output=True, wait=True, update_service_list=True):
+        pass
+
+    def stop(self, instance_name="", capture_output=True, update_service_list=True):
+        pass
+
+
+def suse_service_class_factory(name, api=None):
+    if name == 'dirsrv':
+        return SuseDirectoryService(name, api)
+    if name == 'ipa':
+        return SuseIPAService(name, api)
+    if name == 'sshd':
+        return SuseSSHService(name, api)
+    if name in ('pki-cad', 'pki_cad', 'pki-tomcatd', 'pki_tomcatd'):
+        return SuseCAService(name, api)
+    if name == 'named':
+        return SuseNamedService(name, api)
+    if name in ('ods-enforcerd', 'ods_enforcerd'):
+        return SuseODSEnforcerdService(name, api)
+    if name == 'certmonger':
+        return SuseCertmongerService(api)
+    return SuseService(name, api)
+
+
+class SuseServices(base_services.KnownServices):
+    def service_class_factory(self, name, api):
+        return suse_service_class_factory(name, api)
+
+    # Credits to upstream developer
+    def __init__(self):
+        import ipalib
+        services = dict()
+        for s in base_services.wellknownservices:
+            services[s] = self.service_class_factory(s, ipalib.api)
+        super().__init__(services, api)
+
+
+timedate_services = ['ntpd']
+service = suse_service_class_factory
+knownservices = SuseServices()
diff --git a/ipaplatform/suse/tasks.py b/ipaplatform/suse/tasks.py
new file mode 100644
index 0000000..ffe031c
--- /dev/null
+++ b/ipaplatform/suse/tasks.py
@@ -0,0 +1,278 @@
+# Authors: Howard Guo <hguo@suse.com>
+# Copyright (C) 2015 SUSE Linux GmbH
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+import os
+import stat
+import socket
+import sys
+import urllib
+import base64
+
+from subprocess import CalledProcessError
+from nss.error import NSPRError
+from pyasn1.error import PyAsn1Error
+from ipapython.ipa_log_manager import root_logger, log_mgr
+from ipapython import ipautil
+import ipapython.errors
+from ipalib import x509
+from ipaplatform.paths import paths
+from ipaplatform.base.tasks import BaseTaskNamespace
+
+log = log_mgr.get_logger(__name__)
+
+class SuseTaskNamespace(BaseTaskNamespace):
+
+    def restore_context(self, filepath, restorecon=paths.SBIN_RESTORECON):
+        pass
+
+    def check_selinux_status(self, restorecon=paths.RESTORECON):
+        pass
+
+    def restore_pre_ipa_client_configuration(self, fstore, statestore,
+                                             was_sssd_installed,
+                                             was_sssd_configured):
+        print('FIXME: restore_pre_ipa_client_configuration is called')
+        pass
+
+    def set_nisdomain(self, nisdomain):
+        print('FIXME: set_nisdomain is called')
+        pass
+
+    def modify_nsswitch_pam_stack(self, sssd, mkhomedir, statestore):
+        print('FIXME: modify_nsswitch_pam_stack is called')
+        pass
+
+    def modify_pam_to_use_krb5(self, statestore):
+        print('FIXME: modify_pam_to_use_krb5 is called')
+        pass
+
+    # Credits to upstream developer
+    def reload_systemwide_ca_store(self):
+        try:
+            ipautil.run([paths.UPDATE_CA_TRUST])
+        except CalledProcessError as e:
+            root_logger.error(
+                "Could not update systemwide CA trust database: %s", e)
+            return False
+        else:
+            root_logger.info("Systemwide CA database updated.")
+            return True
+
+    # Credits to upstream developer
+    def insert_ca_certs_into_systemwide_ca_store(self, ca_certs):
+        # pylint: disable=ipa-forbidden-import
+        from ipalib import x509  # FixMe: break import cycle
+        from ipalib.errors import CertificateError
+        # pylint: enable=ipa-forbidden-import
+
+        new_cacert_path = paths.SYSTEMWIDE_IPA_CA_CRT
+
+        if os.path.exists(new_cacert_path):
+            try:
+                os.remove(new_cacert_path)
+            except OSError as e:
+                root_logger.error(
+                    "Could not remove %s: %s", new_cacert_path, e)
+                return False
+
+        new_cacert_path = paths.IPA_P11_KIT
+
+        try:
+            f = open(new_cacert_path, 'w')
+        except IOError as e:
+            root_logger.info("Failed to open %s: %s" % (new_cacert_path, e))
+            return False
+
+        f.write("# This file was created by IPA. Do not edit.\n"
+                "\n")
+
+        has_eku = set()
+        for cert, nickname, trusted, ext_key_usage in ca_certs:
+            try:
+                subject = cert.subject_bytes
+                issuer = cert.issuer_bytes
+                serial_number = cert.serial_number_bytes
+                public_key_info = cert.public_key_info_bytes
+            except (PyAsn1Error, ValueError, CertificateError) as e:
+                root_logger.warning(
+                    "Failed to decode certificate \"%s\": %s", nickname, e)
+                continue
+
+            label = urllib.parse.quote(nickname)
+            subject = urllib.parse.quote(subject)
+            issuer = urllib.parse.quote(issuer)
+            serial_number = urllib.parse.quote(serial_number)
+            public_key_info = urllib.parse.quote(public_key_info)
+
+            obj = ("[p11-kit-object-v1]\n"
+                   "class: certificate\n"
+                   "certificate-type: x-509\n"
+                   "certificate-category: authority\n"
+                   "label: \"%(label)s\"\n"
+                   "subject: \"%(subject)s\"\n"
+                   "issuer: \"%(issuer)s\"\n"
+                   "serial-number: \"%(serial_number)s\"\n"
+                   "x-public-key-info: \"%(public_key_info)s\"\n" %
+                   dict(label=label,
+                        subject=subject,
+                        issuer=issuer,
+                        serial_number=serial_number,
+                        public_key_info=public_key_info))
+            if trusted is True:
+                obj += "trusted: true\n"
+            elif trusted is False:
+                obj += "x-distrusted: true\n"
+            obj += "{pem}\n\n".format(
+                pem=cert.public_bytes(x509.Encoding.PEM).decode('ascii'))
+            f.write(obj)
+
+            if (cert.extended_key_usage is not None and
+                    public_key_info not in has_eku):
+                try:
+                    ext_key_usage = cert.extended_key_usage_bytes
+                except PyAsn1Error as e:
+                    root_logger.warning(
+                        "Failed to encode extended key usage for \"%s\": %s",
+                        nickname, e)
+                    continue
+                value = urllib.parse.quote(ext_key_usage)
+                obj = ("[p11-kit-object-v1]\n"
+                       "class: x-certificate-extension\n"
+                       "label: \"ExtendedKeyUsage for %(label)s\"\n"
+                       "x-public-key-info: \"%(public_key_info)s\"\n"
+                       "object-id: 2.5.29.37\n"
+                       "value: \"%(value)s\"\n\n" %
+                       dict(label=label,
+                            public_key_info=public_key_info,
+                            value=value))
+                f.write(obj)
+                has_eku.add(public_key_info)
+
+        f.close()
+
+        # Add the CA to the systemwide CA trust database
+        if not self.reload_systemwide_ca_store():
+            return False
+
+        return True
+
+    # Credits to upstream developer
+    def remove_ca_certs_from_systemwide_ca_store(self):
+        result = True
+        update = False
+
+        # Remove CA cert from systemwide store
+        for new_cacert_path in (paths.IPA_P11_KIT,
+                                paths.SYSTEMWIDE_IPA_CA_CRT):
+            if not os.path.exists(new_cacert_path):
+                continue
+            try:
+                os.remove(new_cacert_path)
+            except OSError as e:
+                root_logger.error(
+                    "Could not remove %s: %s", new_cacert_path, e)
+                result = False
+            else:
+                update = True
+
+        if update:
+            if not self.reload_systemwide_ca_store():
+                return False
+
+        return result
+
+    # Credits to upstream developer
+    def backup_and_replace_hostname(self, fstore, statestore, hostname):
+        old_hostname = socket.gethostname()
+        try:
+            ipautil.run([paths.BIN_HOSTNAME, hostname])
+        except ipautil.CalledProcessError as e:
+            print >>sys.stderr, ("Failed to set this machine hostname to "
+                                 "%s (%s)." % (hostname, str(e)))
+
+        filepath = paths.ETC_HOSTNAME
+        if os.path.exists(filepath):
+            # read old hostname
+            with open(filepath, 'r') as f:
+                for line in f.readlines():
+                    line = line.strip()
+                    if not line or line.startswith('#'):
+                        # skip comment or empty line
+                        continue
+                    old_hostname = line
+                    break
+            fstore.backup_file(filepath)
+
+        with open(filepath, 'w') as f:
+            f.write("%s\n" % hostname)
+        os.chmod(filepath,
+                 stat.S_IRUSR | stat.S_IWUSR | stat.S_IRGRP | stat.S_IROTH)
+        os.chown(filepath, 0, 0)
+        self.restore_context(filepath)
+
+        # store old hostname
+        statestore.backup_state('network', 'hostname', old_hostname)
+
+    # Credits to upstream developer
+    def restore_network_configuration(self, fstore, statestore):
+        old_filepath = paths.SYSCONFIG_NETWORK
+        old_hostname = statestore.get_state('network', 'hostname')
+        hostname_was_configured = False
+
+        if fstore.has_file(old_filepath):
+            # This is Fedora >=18 instance that was upgraded from previous
+            # Fedora version which held network configuration
+            # in /etc/sysconfig/network
+            old_filepath_restore = paths.SYSCONFIG_NETWORK_IPABKP
+            fstore.restore_file(old_filepath, old_filepath_restore)
+            print("Deprecated configuration file '%s' was restored to '%s'" \
+                    % (old_filepath, old_filepath_restore))
+            hostname_was_configured = True
+
+        filepath = paths.ETC_HOSTNAME
+        if fstore.has_file(filepath):
+            fstore.restore_file(filepath)
+            hostname_was_configured = True
+
+        if not hostname_was_configured and old_hostname:
+            # hostname was not configured before but was set by IPA. Delete
+            # /etc/hostname to restore previous configuration
+            try:
+                os.remove(filepath)
+            except OSError:
+                pass
+
+    def set_selinux_booleans(self, required_settings, backup_func=None):
+        return False # FIXME?
+
+    # Credits to upstream developer
+    def create_system_user(self, name, group, homedir, shell, uid = None, gid = None, comment = None):
+        if name == 'pkiuser':
+            if uid is None:
+                uid = 29
+            if gid is None:
+                gid = 29
+            if comment is None:
+                comment = 'CA System User'
+        if name == 'dirsrv':
+            if comment is None:
+                comment = 'DS System User'
+
+        super().create_system_user(name, group,
+            homedir, shell, uid, gid, comment)
+
+
+tasks = SuseTaskNamespace()
+
-- 
1.7.1

